#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('testApp:server');
var http = require('http');
var pg = require('pg');
//var conString = "postgres://postgres:Blazeteam1@localhost/test"
var conString = process.env.DATABASE_URL
console.log(conString)
/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
var io = require('socket.io')(server);
var client = new pg.Client(conString);
client.connect();

var timerManagement = function(data){
  var interval = {}

  var action = function(query, queryData, data, callback){
    client.query(query, queryData, function(err, result){
      err ? console.log(err) : callback(data, result.rows)
    })
  }

  var updateTime = function(data){
    var query = "update test.matches set remaining_time = remaining_time - 1 where id = $1 returning remaining_time"
    var queryData = [data.match.id]
    action(query, queryData, data, endTimer)
  }

  var endTimer = function(data, results){
    data.socketIO.to(data.streamer).emit('remainingTime', {remaining_time: results[0]['remaining_time']})
    if(results[0]['remaining_time'] == 0){
      var queryString = "update test.matches set remaining_time = 0, betting = false where id = $1 returning *"
      var queryData = [data.match.id]
      action(queryString, queryData, data, closeBetting)
    }
  }

  var closeBetting = function(data, results){
    data.socketIO.to(data.streamer).emit('bettingClosed', results[0])
    clearInterval(interval[data.streamer]);
    delete interval[data.streamer]
  }
}

var countDown = new timerManagement();

var generalQuery = function(emitName, query, queryData, socket, room, callback){
  client.query(query, queryData, function(err, result){
    err ? console.log(err) : callback(emitName, result.rows, socket, room, data)
  })
}

var updateRoom = function(emitName, data, socket, room, data){
  socketIO.to(room).emit(emitName, data)
}

var updateSelf = function(emitName, data, socket, room, data){
  userSocket.emit(emitName, data)
}

var streamView = io
  .of('/stream')
  .on('connection', function(socket){
    //General
    socket.on('leaveRoom', function(data){
      console.log('leaving room: ', data.streamer)
      socket.leave(data.streamer.username)
    })
    socket.on('getCurrentMatch', function(data){
      getCurrentMatch(data, socket)
    })
    socket.on('disconnect', function(data){
      console.log('disconnected from: ')
      removeUser(socket)
    })
    socket.on('getOpenEvents', function(data){
      var emitName = "openEvents"
      var queryString = "select * from test.events where streamer_id = $1 and closed = false";
      var queryData = [data.streamer.id]
      if(data.updateStatus == "self"){
        generalQuery(emitName, query, queryData, socket, false, updateSelf)
      }else{
        generalQuery(emitName, query, queryData, streamView, data.streamer.username, updateSelf)
      }
    })
    socket.on('getMatches', function(data){
      var emitName = 'matches'
      var query = "select tm.players, tm.id, te.name from test.matches tm join test.events te on tm.event_id = te.id where tm.event_id = $1 order by tm.id desc"
      var queryData = [
        data.event.id
      ]
      if(data.updateStatus == "self"){
        generalQuery(emitName, query, queryData, socket, false, updateSelf)
      }else{
        generalQuery(emitName, query, queryData, streamView, data.streamer.username, updateSelf)
      }
    })
    socket.on('getParticipants', function(data){
      var emitName = "currentEventUsers"
      var query = "select * from test.entries te join test.users tu on te.user_id = tu.id where te.event_id = $1 order by te.ante desc"
      var queryData = [data.event.id]
      if(data.updateStatus == "self"){
        generalQuery(emitName, query, queryData, socket, false, updateSelf)
      }else{
        generalQuery(emitName, query, queryData, streamView, data.streamer.username, updateSelf)
      }
    })
    socket.on('getCurrentBets', function(data){
      var query = "select b.*, u.username, u.email from test.bets b join test.users u on b.user_id = u.id where match_id = $1 order by b.id desc"
      var emitName = 'currentBets'
      var queryData = [
        data.match.id
      ]
      if(data.updateStatus == "self"){
        generalQuery(emitName, query, queryData, socket, false, updateSelf)
      }else{
        generalQuery(emitName, query, queryData, streamView, data.streamer.username, updateSelf)
      }
    })

    //User
    socket.on('getStreamInfo', function(data){
      socket.username = data.user.username;
      socket.room = data.streamer;
      socket.join(data.streamer)
      streamInfo(data, socket)
      updateParticipants(data, socket, streamView)
    })
    socket.on('getUserInfo', function(data){
      userInfo(data, socket)
    })
    socket.on('getEventEntry', function(data){
      var query = "select * from test.entries where event_id = $1 and user_id = $2"
      var queryData = [
        data.event.id,
        data.user.id
      ]
      var emitName = "eventEntry"
      generalQuery(emitName, query, queryData, socket, false, updateSelf)
    })
    socket.on('addBet', function(data){
      var query = "insert into test.bets (match_id, player_id, amount, user_id) values ($1, $2, $3, $4) returning *"
      var queryData = [data.bet.match_id, data.bet.player, data.bet.amount, data.bet.user_id]
      var emitName = "bet"

      var removeMoneyFromAnte = function(){
        var query = "update test.entries set ante = ante - $1 where user_id = $2 and event_id = $3 returning *"
        var queryData = [data.bet.amount, data.bet.user_id, data.event.id]
        var emitName = "update"
        generalQuery(emitName, query, queryData, socket, false, updateSelf)
      }

      generalQuery(emitName, query, queryData, socket, false, removeMoneyFromAnte)
    })

    //Streamer
    socket.on('getConnection', function(data){
      socket.join(data.streamer.username)
      getCurrentEvent(data, socket)
    })
    socket.on('submitWinner', function(data){
      submitWinner(data, streamView)
    })
    socket.on('startPlaying', function(data){
      startPlaying(data, streamView)
    })
    socket.on('sendNewMatch', function(data){
      var query = "insert into test.matches (players, game, remaining_time, streamer_id, event_id) values ($1, $2, $3, $4, $5) returning *"
      var queryData = [data.players, data.game, data.remaining_time, data.streamer_id, data.event_id]
      var emitName = "startNewMatch"
      var startTimer = function(){
        var gameObject = {
          match: results[0],
          socketIO: socketIO,
          stream_name: data.stream_name,
          streamer: data.streamer
        }
        
        socketIO.to(room).emit(emitName, results[0])
        if(typeof countDown.interval[data.streamer] !== 'undefined'){
          clearInterval(countDown.interval[data.streamer]);
        }
          data.socketIO = streamView
          interval[data.streamer] = setInterval(countDown, 1000, gameObject);
        }
      }
      generalQuery()
    })

    var startNewMatch = function(data, rooms, socket){
      var queryString = "insert into test.matches (players, game_id, remaining_time, streamer_id, event_id) values ($1, $2, $3, $4, $5) returning *"
      client.query(queryString, [data.players, 1, data.remaining_time, data.streamer_id, data.event_id], function(err, result){
        if(err){
          console.log(err)
        }else{
          var gameObject = {
            match: result.rows[0],
            socketIO: streamView,
            stream_name: data.stream_name,
            streamer: data.streamer
          }
          rooms.to(data.stream_name).emit('startNewMatch', result.rows[0])
          var match = result.rows[0]
          socket.emit('currentMatch', {
            match: match
          })
          
          if(typeof interval[data.streamer] !== 'undefined'){
            clearInterval(interval[data.streamer]);
          }
            data.socketIO = streamView
            interval[data.streamer] = setInterval(countDown, 1000, gameObject);
          }
      })
    }
  })
/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
